================================================================================
                    MEET PROJECT - DEVELOPMENT NOTES
================================================================================

This file documents the implementation progress and architecture decisions
for the meeting application. Each day's work is documented with WHAT, WHY,
and WHERE explanations.

================================================================================
DAY 1 – PROJECT FOUNDATION
================================================================================

WHAT WAS IMPLEMENTED:
---------------------

1. Monorepo Structure
   - Three main directories: frontend/, backend/, shared/
   - Root package.json with scripts to run both frontend and backend
   - Shared TypeScript types in shared/types/ for code reuse

2. Frontend Setup (React + Vite)
   - React 19 with TypeScript
   - Vite as build tool (fast HMR)
   - TailwindCSS for styling
   - React Router for navigation
   - Redux Toolkit for state management
   - Basic routing: Home, Create Meeting, Join Meeting pages

3. Backend Setup (Express + Prisma)
   - Express 5 with TypeScript
   - Prisma ORM for database management
   - PostgreSQL database connection
   - Modular structure: modules/, routes/, controllers/, services/
   - Environment configuration with dotenv

4. Database Schema (Prisma)
   - User model (id, email, name, timestamps)
   - Meeting model (id, title, meetingCode, password, scheduledAt, hostId)
   - Transcript model (for future AI features)
   - Relationships: User -> Meeting (host), Meeting -> Transcript

5. Shared TypeScript Types
   - User interface
   - Meeting interface
   - TranscriptSummary interface
   - Located in shared/types/ for type safety across frontend and backend

WHY THIS STRUCTURE:
-------------------

- Monorepo: Keeps related code together, enables shared types, easier
  development workflow with single repository

- React + Vite: Modern, fast development experience with hot module
  replacement. Vite is much faster than Create React App.

- Express + Prisma: Express is lightweight and flexible. Prisma provides
  type-safe database access and migrations, reducing SQL boilerplate.

- PostgreSQL: Reliable, robust relational database perfect for meeting
  data, user management, and future features.

- Shared Types: Ensures frontend and backend use the same data structures,
  preventing type mismatches and bugs.

WHERE IT LIVES:
--------------

- Frontend: frontend/src/
  - Pages: frontend/src/pages/
  - Components: frontend/src/components/
  - Store: frontend/src/store/
  - Services: frontend/src/services/

- Backend: backend/src/
  - Modules: backend/src/modules/ (meetings, auth, users, ai)
  - Routes: backend/src/routes/
  - Config: backend/src/config/ (env, db)

- Shared: shared/types/
  - Type definitions used by both frontend and backend

- Database: backend/prisma/
  - Schema: backend/prisma/schema.prisma
  - Migrations: backend/prisma/migrations/

================================================================================
DAY 2 – MEETING SCHEDULING
================================================================================

WHAT WAS IMPLEMENTED:
---------------------

1. Meeting Creation API
   - POST /api/meetings
   - Generates unique 8-character meeting code (alphanumeric)
   - Optional password protection (hashed with bcrypt)
   - Optional scheduled date/time
   - Returns meeting code and shareable join URL

2. Meeting Join/Validation API
   - POST /api/meetings/join
   - Validates meeting code exists
   - Validates password if meeting is password-protected
   - Returns meeting details on success

3. Get Meeting by Code API
   - GET /api/meetings/:meetingCode
   - Returns meeting details including hasPassword flag
   - Used for checking if password is required before joining

4. Frontend Meeting Creation Page
   - Form to create meeting with title, password, scheduled time
   - Generates shareable link
   - Copy-to-clipboard functionality
   - Stores meeting in Redux as host

5. Frontend Join Meeting Page
   - Input for meeting code or full meeting URL
   - Auto-extracts meeting code from pasted URLs
   - Checks if password is required (debounced API call)
   - Password input shown conditionally
   - Stores meeting in Redux as participant

6. Meeting State Management (Redux)
   - meetingSlice with actions:
     - setMeetingAsHost: When user creates meeting
     - setMeetingAsParticipant: When user joins meeting
     - clearMeeting: When user leaves
   - Tracks: currentMeeting, meetingCode, isHost, joinUrl

7. Meeting Code Generation
   - Utility function: backend/src/utils/generateMeetingCode.ts
   - 8-character alphanumeric codes
   - Ensures uniqueness by checking database

8. Password Hashing
   - Utility function: backend/src/utils/hash.ts
   - Uses bcrypt for secure password storage
   - Never stores plain text passwords

WHY THESE FEATURES:
-------------------

- Meeting Codes: Simple, human-readable way to join meetings without
  complex authentication. Users can share codes easily.

- Password Protection: Allows meeting hosts to restrict access to
  authorized participants only.

- Scheduled Meetings: Enables planning meetings in advance, useful for
  recurring or planned sessions.

- Shareable Links: Makes it easy to invite participants - just copy and
  paste the link.

- Redux State: Centralized state management ensures meeting data is
  available across components and persists during navigation.

- URL Extraction: User-friendly feature - users can paste full URLs and
  the app extracts the code automatically.

WHERE IT LIVES:
--------------

- Backend APIs:
  - Controller: backend/src/modules/meetings/meetings.controller.ts
  - Service: backend/src/modules/meetings/meetings.service.ts
  - Routes: backend/src/modules/meetings/meetings.routes.ts

- Frontend Pages:
  - Create: frontend/src/pages/CreateMeetingPage.tsx
  - Join: frontend/src/pages/JoinMeetingPage.tsx
  - Meeting Details: frontend/src/pages/MeetingPage.tsx

- Frontend Services:
  - API Client: frontend/src/services/meetingApi.ts
  - HTTP Client: frontend/src/utils/apiClient.ts

- State Management:
  - Redux Slice: frontend/src/store/slices/meetingSlice.ts

- Utilities:
  - Code Generation: backend/src/utils/generateMeetingCode.ts
  - Password Hashing: backend/src/utils/hash.ts

================================================================================
DAY 3 – REALTIME COMMUNICATION
================================================================================

WHAT WAS IMPLEMENTED:
---------------------

1. Socket.io Server (Backend)
   - WebSocket server for real-time bidirectional communication
   - Attached to HTTP server in backend/src/server.ts
   - CORS configured for frontend origin
   - Room-based architecture (each meeting code is a room)

2. Socket Events Implemented:
   a) join-meeting
      - Payload: { meetingCode, userName }
      - Socket joins room named after meetingCode
      - Broadcasts "user-joined" to other room members
      - Confirms join with "joined-meeting" to sender

   b) leave-meeting
      - Payload: { meetingCode, userName }
      - Socket leaves room
      - Broadcasts "user-left" to room members

   c) send-message
      - Payload: { meetingCode, message, sender }
      - Broadcasts "message-received" to all in room

   d) send-reaction
      - Payload: { meetingCode, reaction, sender }
      - Broadcasts "reaction-received" to all in room

   e) disconnect
      - Automatic cleanup when socket disconnects
      - Notifies room members of departure

3. Socket.io Client (Frontend)
   - Service layer: frontend/src/services/socket.service.ts
   - Functions: connectSocket(), joinMeeting(), leaveMeeting(),
     sendMessage(), sendReaction(), disconnectSocket()
   - Event subscription helpers: onSocketEvent(), offSocketEvent()

4. Meeting Room Page
   - New page: frontend/src/pages/MeetingRoomPage.tsx
   - Features:
     * User name input before joining
     * Socket connection on mount
     * Real-time participant join/leave notifications
     * Chat messaging interface
     * Emoji reactions (8 common reactions)
     * Activity feed showing participant events
     * Connection status indicator
   - UI Layout:
     * Main area (placeholder for video in Day 4)
     * Sidebar with Activity, Reactions, and Chat sections

5. Routing Update
   - Updated /meet/:meetingCode route to use MeetingRoomPage
   - Maintains backward compatibility

WHY WEBSOCKETS ARE REQUIRED:
---------------------------

- Real-time Communication: HTTP is request-response only. WebSockets
  enable server to push updates to clients instantly without polling.

- Low Latency: Perfect for chat, reactions, and participant presence.
  Messages appear instantly to all participants.

- Foundation for WebRTC: Socket.io will be used in Day 4 to exchange
  WebRTC signaling data (ICE candidates, offers, answers) between peers.
  WebRTC needs a signaling server to establish peer-to-peer connections.

- Scalability: Room-based architecture allows efficient message routing.
  Only participants in a meeting room receive relevant events.

- Bidirectional: Both client and server can initiate communication,
  essential for real-time features.

WHERE IT LIVES:
--------------

- Backend Socket Server:
  - Implementation: backend/src/modules/sockets/socket.ts
  - Integration: backend/src/server.ts (initializes socket server)

- Frontend Socket Client:
  - Service: frontend/src/services/socket.service.ts
  - Usage: frontend/src/pages/MeetingRoomPage.tsx

- Dependencies:
  - Backend: socket.io (v4.8.1)
  - Frontend: socket.io-client (v4.8.1)

- Configuration:
  - Socket URL: Defaults to http://localhost:4000
  - Can be overridden with VITE_SOCKET_URL environment variable

FUTURE EXTENSIONS (Day 4+):
---------------------------

- WebRTC Signaling: Socket.io will handle:
  * offer: WebRTC offer from peer
  * answer: WebRTC answer from peer
  * ice-candidate: ICE candidate exchange
  * peer-joined: Notify when peer is ready for connection

- Video/Audio: WebRTC peer-to-peer connections for media streaming

- Screen Sharing: WebRTC screen capture API integration

- Recording: MediaRecorder API for meeting recordings

================================================================================
DAY 4 – VIDEO & AUDIO (LIVEKIT)
================================================================================

WHAT WAS IMPLEMENTED:
---------------------

1. LiveKit Server SDK Integration (Backend)
   - Installed livekit-server-sdk package
   - Created token generation service
   - Secure room-based access control
   - Meeting validation before token generation

2. Token Generation API
   - POST /api/webrtc/token
   - Request: { meetingCode, userName }
   - Response: { token, url }
   - Validates meeting exists before generating token
   - Binds token to meetingCode (room) and user identity

3. LiveKit React SDK Integration (Frontend)
   - Installed @livekit/components-react and livekit-client
   - Created VideoRoom component
   - Auto-connects to LiveKit room on mount
   - Renders video tiles for all participants
   - Responsive grid layout (1, 2, or 3+ participants)

4. VideoRoom Component Features
   - Connects to LiveKit using token + URL
   - Auto joins meeting room
   - Video tiles for participants
   - Audio track rendering
   - Connection state management
   - Error handling (token failure, connection lost)

5. MeetingRoomPage Integration
   - Fetches LiveKit token after socket join succeeds
   - Renders VideoRoom in main content area
   - Chat and reactions still work independently
   - Graceful fallback if video connection fails

6. Environment Variables
   - LIVEKIT_API_KEY: LiveKit API key
   - LIVEKIT_API_SECRET: LiveKit API secret
   - LIVEKIT_URL: LiveKit server URL

WHY SFU (SELECTIVE FORWARDING UNIT) IS NEEDED:
------------------------------------------------

- P2P Limitations: Direct peer-to-peer WebRTC connections don't scale well.
  With 5+ participants, each peer must send/receive streams from every other
  peer, consuming massive bandwidth and CPU.

- SFU Solution: LiveKit uses an SFU architecture where:
  * Each participant sends ONE stream to the server
  * Server forwards streams to other participants
  * Reduces bandwidth: O(n) instead of O(n²)
  * Better performance for large meetings

- LiveKit Benefits:
  * Production-ready SFU infrastructure
  * Handles NAT traversal automatically
  * Built-in scaling and load balancing
  * Low latency media forwarding
  * Supports 100+ participants per room

HOW THIS PREPARES FOR DAY 5:
----------------------------

- Mic/Camera Toggle: Token permissions (canPublish) are already set up.
  Day 5 will add UI controls to enable/disable tracks.

- Screen Sharing: Room structure supports multiple track sources.
  Day 5 will add screen share track publishing.

- Recording: LiveKit has built-in recording capabilities.
  Day 6 will add recording hooks and controls.

WHERE IT LIVES:
--------------

- Backend LiveKit Service:
  - Service: backend/src/modules/webrtc/livekit.service.ts
  - Controller: backend/src/modules/webrtc/webrtc.controller.ts
  - Routes: backend/src/modules/webrtc/webrtc.routes.ts
  - Integration: backend/src/routes/index.ts

- Backend Configuration:
  - Environment: backend/src/config/env.ts
  - Variables: LIVEKIT_API_KEY, LIVEKIT_API_SECRET, LIVEKIT_URL

- Frontend Video Component:
  - Component: frontend/src/components/VideoRoom.tsx
  - API Service: frontend/src/services/livekitApi.ts
  - Integration: frontend/src/pages/MeetingRoomPage.tsx

- Dependencies:
  - Backend: livekit-server-sdk (^2.5.4)
  - Frontend: @livekit/components-react (^2.3.0), livekit-client (^2.5.3)

ARCHITECTURE DECISIONS:
-----------------------

- Separation of Concerns:
  * Socket.io: Signaling, chat, reactions (text-based communication)
  * LiveKit: Video/audio streaming (media communication)
  * Clean separation allows independent scaling and maintenance

- Token Security:
  * Tokens are generated server-side only
  * Meeting validation ensures only valid meetings get tokens
  * Tokens are scoped to specific room (meetingCode)
  * Future: JWT auth can be added to token generation

- Room Naming:
  * Uses meetingCode as room name
  * Ensures each meeting has isolated video room
  * Matches Socket.io room architecture

- Error Handling:
  * Video connection failures don't break chat/reactions
  * Graceful degradation: users can still communicate via text
  * Clear error messages for debugging

FUTURE EXTENSIONS (Day 5+):
---------------------------

- Day 5: Mic/Camera Controls
  * Toggle audio/video tracks
  * UI controls for mute/unmute
  * Visual indicators for muted participants

- Day 5: Screen Sharing
  * Screen capture track publishing
  * UI button to start/stop sharing
  * Grid layout updates for screen shares

- Day 6: Recording
  * LiveKit recording hooks
  * Start/stop recording controls
  * Recording status indicators

- Future: Participant Management
  * Kick/ban participants (host controls)
  * Participant list with video/audio status
  * Raise hand feature

================================================================================
DAY 5 – MEDIA CONTROLS & SCREEN SHARING
================================================================================

WHAT WAS IMPLEMENTED:
---------------------

1. MediaControls Component
   - Fixed bottom toolbar with media control buttons
   - Toggle microphone ON/OFF
   - Toggle camera ON/OFF
   - Start/Stop screen sharing
   - Leave meeting button
   - Visual state indicators (active/inactive colors)
   - Loading states for screen sharing

2. Video Tile Enhancements
   - Mic muted icon overlay on video tiles
   - Camera off placeholder with avatar (first letter of name)
   - Screen share highlighting with blue ring border
   - Participant name overlay on video tiles
   - Media state indicators (mic/camera status badges)

3. Media State Management
   - Real-time sync with LiveKit track states
   - Event listeners for track published/unpublished
   - Event listeners for track muted/unmuted
   - State persists across re-renders
   - Clean cleanup on component unmount

4. Screen Sharing Implementation
   - Browser screen capture API integration
   - Separate track source (Track.Source.ScreenShare)
   - Audio capture from screen share
   - Automatic stop handling when user ends via browser UI
   - Permission error handling with user-friendly messages
   - Screen shares prioritized in grid layout

5. LiveKit Track Control
   - Audio track mute/unmute via track.mute() and track.unmute()
   - Video track mute/unmute for camera control
   - Track publishing for screen sharing
   - Track unpublishing for stopping screen share

6. Optional Socket.io Events (Minimal Implementation)
   - media-state-changed event emission on media toggle
   - Used for UI sync and future analytics
   - Backend handler logs events (can be extended for broadcasting)
   - Minimal implementation - doesn't affect core functionality

WHY THESE FEATURES:
-------------------

- Media Controls: Essential for user control over their media. Users need to
  mute/unmute mic and camera during meetings for privacy and bandwidth management.

- Visual Indicators: Critical for UX - participants need to see who is muted,
  who has camera off, and who is sharing screen. This prevents confusion and
  improves meeting flow.

- Screen Sharing: Core feature for presentations, demos, and collaboration.
  Separate track source allows screen shares to be displayed prominently while
  maintaining camera views.

- State Management: Real-time sync ensures UI always reflects actual media state.
  Event-driven updates prevent state drift and ensure accurate indicators.

HOW LIVEKIT HANDLES MEDIA TRACKS:
----------------------------------

- Audio Tracks: Each participant can publish one audio track. Tracks can be
  muted/unmuted without unpublishing. Muted tracks still exist but send silence.

- Video Tracks: Participants can publish multiple video tracks:
  * Camera track (Track.Source.Camera) - webcam feed
  * Screen share track (Track.Source.ScreenShare) - screen capture
  * Screen share audio (Track.Source.ScreenShareAudio) - system audio

- Track Lifecycle:
  * Publish: Create and share track with other participants
  * Mute/Unmute: Temporarily disable/enable track without unpublishing
  * Unpublish: Remove track completely

- Why Screen Sharing is Separate:
  * Allows simultaneous camera and screen share
  * Different quality/bitrate requirements
  * Can be prioritized in UI (screen share shown larger)
  * Enables recording of both sources separately

HOW THIS PREPARES FOR DAY 6:
----------------------------

- Recording Hooks: Media state tracking provides foundation for recording
  controls. Recording can start/stop based on media state.

- Audio Capture: Mic state management enables selective audio recording and
  AI transcription. Only active audio tracks need transcription.

- Media State Analytics: Track state changes can be logged for analytics:
  * How often users mute/unmute
  * Average meeting duration with camera on
  * Screen sharing usage patterns

WHERE IT LIVES:
--------------

- Media Controls Component:
  - Component: frontend/src/components/MediaControls.tsx
  - Integration: frontend/src/components/VideoRoom.tsx

- Video Tile Enhancements:
  - Component: frontend/src/components/VideoRoom.tsx (RoomContent)
  - Visual indicators: Overlay components in video tile rendering

- State Management:
  - MediaControls.tsx: useState hooks for local state
  - Event listeners: LiveKit participant events
  - Sync logic: useEffect hooks monitoring track publications

- Screen Sharing:
  - Implementation: MediaControls.tsx (handleToggleScreenShare)
  - Browser API: navigator.mediaDevices.getDisplayMedia()
  - Track Publishing: localParticipant.publishTrack()

- Optional Socket Events:
  - Frontend: frontend/src/services/socket.service.ts (emitMediaStateChanged)
  - Backend: backend/src/modules/sockets/socket.ts (media-state-changed handler)
  - Usage: Emitted when mic/camera/screen share state changes

ARCHITECTURE DECISIONS:
-----------------------

- Fixed Bottom Toolbar: Similar to Zoom/Google Meet UX. Always accessible,
  doesn't interfere with video content. Positioned with fixed positioning and
  centered horizontally.

- Screen Share Priority: Screen shares appear first in grid layout, then
  camera feeds. This matches user expectations - shared content is most important.

- Avatar Placeholder: When camera is off, show first letter of participant name
  in circular avatar. Provides visual identity without video feed.

- State Sync: Don't rely solely on local state. Always sync with actual track
  states via event listeners. Prevents UI/state mismatches.

- Error Handling: Screen sharing permission errors are caught and displayed to
  user. Graceful degradation - meeting continues even if screen share fails.

FUTURE EXTENSIONS (Day 6+):
---------------------------

- Day 6: Recording
  * Use media state to determine what to record
  * Record only active tracks (skip muted audio/video)
  * Separate recording tracks for screen shares

- Future: Participant Management
  * Host can mute/unmute other participants
  * Host can disable camera for others
  * Participant list showing media states

- Future: Advanced Controls
  * Virtual backgrounds
  * Audio filters/effects
  * Video quality selection
  * Bandwidth management

================================================================================
NOTES FOR FUTURE DEVELOPMENT
================================================================================

- This file should be appended to, not overwritten, as new features are added
- Each day's work should document WHAT, WHY, and WHERE
- Keep explanations simple and developer-friendly
- Reference file paths and key architectural decisions

================================================================================

